
## 3.1 上下文环境

上下文（Context）泛指CPU在执行代码时，该代码所处的环境与状态。通俗来讲，这些环境状态包括（不仅限）：当前代码所属线程、中断请求级别、CPU寄存器各状态等。





无论是驱动入口函数，还是驱动卸载函数，都隶属于进程ID为4的进程，在笔者的Windows 10测试环境中，进程ID为4的进程为SYSTEM进程，


![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282236436.png)


## 3.2 中断请求级别

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282237986.png)

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282238441.png)

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282241386.png)



## 3.3 驱动异常

主动引发蓝屏的函数：KeBugCheckEx，这个函数的原型如下：
```


```

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282244070.png)




## 3.4 字符串操作

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282244617.png)


UNICODE_STRING的初始化 ，常用的初始化函数为 RtlInitUnicodeString :

```

```

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282246056.png)

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282247645.png)


下面为读者介绍UNICODE_STRING的拷贝操作，拷贝操作可以使用 RtlUnicodeStringCopyString 函数，原型如下：

```

```

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282248184.png)


### 练习点：字符串操作函数库




## 3.5 链表

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282251841.png)

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282251030.png)


### 3.5.1 头节点初始化

InitializeListHead


### 3.5.2 节点插入

InsertHeadList
InsertTailList


### 3.5.3 链表遍历


![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282305047.png)



![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282306986.png)


### 思考点：windbg时怎么打印？

LIST_ENTRY不在结构体头部，如何快速便利整条链表？



### 3.5.4 节点移除

RemoveHeadList
RemoveTailList
RemoveEntryList
IsListEmpty

### 注意点：锁中不建议释放内存


## 3.6 自旋锁

### 3.6.1 使用自旋锁

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282310991.png)


初始化获取一个自旋锁

```
KSPIN_LOCK my_spin_lock;
KeInitializeSpinLock(&my_spin_lock);
```

使用自旋锁

```
KeAcquireSpinLock
KeReleaseSpinLock
```

### 注意点: 锁一般不使用局部变量

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282329364.png)



### 3.6.2 在双向链表中使用自旋锁


```
ExInterlockedInsertHeadList
```




### 3.6.3 使用队列自旋锁提高性能

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282332162.png)


队列自旋锁的使用和普通自旋锁的使用方法基本一样，初始化自旋锁也是使用KeInitializeSpinLock函数，唯一不同的地方是在获取和释放自旋锁时需要使用新的函数：

```
KeInitializeSpinLock
```

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282332842.png)


![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282333621.png)



## 3.7 内存分配

### 3.7.1 常规内存分配

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282335369.png)
![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282336140.png)

```
ExAllocatePoolWithTag

ExFreePoolWithTag
```


### 3.7.2 旁视列表

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282337371.png)


```
ExInitializeNPagedLookasideList

ExAllocateFromNPagedLookasideList

ExDeleteNPagedLookasideList
```


![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282342029.png)
![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282342677.png)



### 练习点:旁氏列表

> 相同的大小的结构体的开辟使用一个旁氏列表就够了,笔者曾经犯过 A B 两条链表都是相同的结构体,但是用了两条旁氏列表的错误



## 3.8 对象与句柄

### 对象与句柄

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282346736.png)
![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282348348.png)


![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282349293.png)


### 引用计数:
### 问题点:指针计数如何独立增加与减少?

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505282351080.png)


### 练习点: CreateEvent 观察句柄值与对象



## 3.9 注册表

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292245714.png)


### 3.9.1 注册表的打开与关闭

### ZwCreateKey



![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292246724.png)



### 3.9.2 注册表的修改

ZwSetValueKey




### 3.9.3 注册表的读取

ZwQueryValueKey




## 练习点：封装注册表操作函数



## 3.10 文件操作

3.10.1 文件的打开与关闭

ZwCreateFile

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292253502.png)



![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292249560.png)
![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292249833.png)





![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292250201.png)

### 补充点：ShareAccess 参数有做过对独占的判断

修改 IRP 时需要调用一个函数：






### 3.10.2 文件的读写

ZwReadFile

ZwWriteFile




## 3.11 线程与事件


### 3.11.1 使用系统线程


![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292255234.png)


PsCreateSystemThread


![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292257839.png)
![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292257097.png)


CustomThreadProc


PsTerminateSystemThread


![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292258922.png)




### 3.11.2 使用同步事件


![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292259512.png)


KeInitlizeEvent

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292300061.png)


KeSetEvent

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292300544.png)




KeResetEvent

![image.png](https://gcmz925-note.oss-cn-shenzhen.aliyuncs.com/gcmz/note202505292305088.png)


通俗一点讲，也就是同步事件在处理完后，会自动设置无信号状态，下次会继续等待
通告事件，会一直开绿灯，直到调用 KeResetEvent 重新设置为无信号状态